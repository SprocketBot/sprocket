"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type ApiToken {
  id: String!
  name: String!
  tokenPrefix: String!
  scopes: [String!]!
  expiresAt: DateTime
  createdAt: DateTime!
  lastUsedAt: DateTime
  usageCount: Float!
  isRevoked: Boolean!
}

type ApiTokenAndSecret {
  id: String!
  name: String!
  tokenPrefix: String!
  scopes: [String!]!
  expiresAt: DateTime
  createdAt: DateTime!
  lastUsedAt: DateTime
  usageCount: Float!
  isRevoked: Boolean!

  """The full secret token. Only validation once upon creation."""
  secret: String!
}

enum AuthPlatform {
  DISCORD
  STEAM
}

input CreatePlayerInput {
  userId: String!
  gameId: String!
  skillGroupId: String!
  salary: String!
}

input CreateScrimInput {
  gameId: String!
  gameModeId: String!
  options: CreateScrimInputOptions
}

input CreateScrimInputOptions {
  """In Minutes"""
  pendingTimeout: Float = 20
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DestroyScrimInput {
  scrimId: String!
}

type EventQueue {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  eventType: EventType!
  payload: String!
  processedAt: DateTime
  status: EventStatus!
  retryCount: Int!
  targetService: EventTarget!
}

enum EventStatus {
  PENDING
  PROCESSED
  FAILED
}

enum EventTarget {
  NOTIFICATIONS
  IMAGE_GEN
  REPLAY_PARSE
  ELO_SERVICE
}

enum EventType {
  MATCH_COMPLETED
  PLAYER_JOINED_QUEUE
  SUBMISSION_CREATED
  MATCH_RATIFIED
}

input FindUserInput {
  id: String
  username: FuzzyString
  active: Boolean
  limit: Float = 50
}

type Fixture {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  game: Game!
  gameMode: GameMode!
  rounds: [Round!]!
  status: MatchStatus!
  startTime: DateTime
  endTime: DateTime
  homeFranchise: Franchise!
  awayFranchise: Franchise!
}

type Franchise {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  name: String!
}

input FuzzyString {
  term: String!
  fuzzy: Boolean = false

  """When set, an empty term returns unfiltered results"""
  allowEmpty: Boolean = true
}

type Game {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  name: String!
  skillGroups: [SkillGroup!]!
  gameModes: [GameMode!]!
}

type GameMode {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  name: String!
  playerCount: Float!
  teamSize: Float!
  game: Game!
}

type GameQueueStats {
  gameId: ID!
  queuedCount: Int!
}

input ListScrimsInput {
  gameId: String
  skillGroupid: String
  state: ScrimState
}

enum LogLevel {
  ERROR
  WARN
  INFO
  DEBUG
  TRACE
}

type Logs {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  timestamp: DateTime!
  level: LogLevel!
  message: String!
  context: String
  service: String!
  method: String
  path: String
  statusCode: Int
  duration: Int
  error: String
  trace: String
  user: User
  userId: String
  requestId: String
  traceId: String
  spanId: String
  tags: String
}

type Match {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  game: Game!
  gameMode: GameMode!
  rounds: [Round!]!
  status: MatchStatus!
  startTime: DateTime
  endTime: DateTime
}

type MatchmakingResult {
  scrimId: ID!
  playerIds: [ID!]!
  gameId: ID!
  skillRating: Int!
}

enum MatchStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

type MatchSubmission {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  match: Match!
  submittedBy: User!
  status: SubmissionStatus!
  submittedData: String!
  submittedAt: DateTime!
  reviewedAt: DateTime
  reviewedBy: User
  rejectionReason: String
}

type Metrics {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  timestamp: DateTime!
  name: String!
  value: Float!
  type: MetricType!
  unit: String
  service: String!
  method: String
  path: String
  labels: String
  user: User
  userId: String
  requestId: String
  traceId: String
  spanId: String
}

enum MetricType {
  COUNTER
  GAUGE
  HISTOGRAM
  SUMMARY
}

type Mutation {
  generateApiToken(name: String!, scopes: [String!]!, expiresAt: DateTime): ApiTokenAndSecret!
  revokeApiToken(tokenId: String!): Boolean!
  createRole(name: String!, displayName: String!, description: String, hierarchy: Int! = 0): Role!
  addPermissionToRole(role: String!, resource: String!, action: String!, scope: String! = "all"): Boolean!
  removePermissionFromRole(role: String!, resource: String!, action: String!, scope: String! = "all"): Boolean!
  assignRoleToUser(userId: Int!, role: String!, scope: String): UserRoleAssignment!
  revokeRoleFromUser(userId: Int!, role: String!): Boolean!
  createScrim(payload: CreateScrimInput!): Scrim!
  destroyScrim(payload: DestroyScrimInput!): Scrim!
  joinScrim(scrimId: String!): Scrim!
  leaveScrim: Scrim!
  alterUserActiveStatus(active: Boolean!, userId: String!): User!
  createPlayer(data: CreatePlayerInput!): Player!
  updatePlayer(data: UpdatePlayerInput!): Player!
  deletePlayer(playerId: String!): Player!
  joinQueue(gameId: String!, skillRating: Int!): Boolean!
  leaveQueue: Boolean!
  processMatchmaking: [MatchmakingResult!]!
}

enum NotificationChannel {
  EMAIL
  PUSH
  SMS
  IN_APP
  DISCORD
  WEBHOOK
}

type NotificationHistory {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  channel: NotificationChannel!
  recipientId: String!
  status: NotificationStatus!
  templateName: String!
  templateData: String!
  errorMessage: String
  retryCount: Int!
  sentAt: DateTime
  template: NotificationTemplate
  user: User
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  RETRYING
}

type NotificationTemplate {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  name: String!
  channel: NotificationChannel!
  content: String!
  defaultData: String!
}

type Permission {
  role: String!
  resource: String!
  action: String!
  scope: String!
  effect: String!
}

type PermissionAuditLog {
  id: ID!
  actorId: Float
  action: String!
  timestamp: DateTime!
  reason: String
}

type Player {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  salary: String!
  user: User!
  game: Game!
  skillGroup: SkillGroup!
}

type PlayerQueueStatus {
  playerId: ID!
  gameId: ID!
  skillRating: Int!
  queuedAt: DateTime!
  position: Int!
}

type PlayerStat {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  player: Player!
  round: Round!
  stats: String!
}

type Query {
  getMyApiTokens: [ApiToken!]!
  getAvailableScopes: [String!]!
  roles: [Role!]!
  role(name: String!): Role
  rolePermissions(role: String!): [Permission!]!
  permissionAuditLogs: [PermissionAuditLog!]!
  pendingScrims(admin: Boolean = false, query: ListScrimsInput): [Scrim!]!
  allScrims(query: ListScrimsInput): [Scrim!]!
  currentScrim: Scrim
  whoami: User!
  users(query: FindUserInput!): [User!]!
  games: [Game!]!
  allSkillGroups: [SkillGroup!]!
  getQueueStatus: PlayerQueueStatus
  getQueueStats(gameId: String): QueueStats!
  getMatchById(id: String!): Match
  getMatchSubmissionById(id: String!): MatchSubmission
  getRoundById(id: String!): Round
  getScheduleGroupById(id: String!): ScheduleGroup
  getScheduleGroupTypeById(id: String!): ScheduleGroupType
  getTeamStatById(id: String!): TeamStat
  getPlayerStatById(id: String!): PlayerStat
  getScrimQueueById(id: String!): ScrimQueue
  getScrimTimeoutById(id: String!): ScrimTimeout
  getEventQueueById(id: String!): EventQueue
  getMetricsById(id: String!): Metrics
  getLogsById(id: String!): Logs
  getUserNotificationPreferenceById(id: String!): UserNotificationPreference
  getNotificationHistoryById(id: String!): NotificationHistory
  getNotificationTemplateById(id: String!): NotificationTemplate
  getFixtureById(id: String!): Fixture
}

type QueueStats {
  totalQueued: Int!
  averageWaitTime: Int!
  gameStats: [GameQueueStats!]!
}

enum QueueStatus {
  QUEUED
  MATCHED
  EXPIRED
  CANCELLED
}

type Role {
  id: ID!
  name: String!
  displayName: String!
  description: String
  hierarchy: Int!
  isActive: Boolean!
  isRestricted: Boolean!
}

type Round {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  match: Match!
  roundNumber: Int!
  isMapCheck: Boolean!
  metadata: String!
  playerStats: [PlayerStat!]!
  teamStats: [TeamStat!]!
}

type ScheduleGroup {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
}

type ScheduleGroupType {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
}

type Scrim {
  participants(admin: Boolean = false): [ScrimParticipant!]
  participantCount: Int!
  id: String!
  authorId: String!
  gameId: String!
  skillGroupId: String!
  gameModeId: String!
  maxParticipants: Float!
  state: ScrimState!
  pendingTtl: Float
  createdAt: DateTime!
  complete: Boolean!
  author: User!
  game: Game!
  skillGroup: SkillGroup!
  gameMode: GameMode!
}

type ScrimParticipant {
  id: String!
  checkedIn: Boolean
  name: String!
}

type ScrimQueue {
  id: String!
  player: Player!
  game: Game!
  skillRating: Int!
  queuedAt: DateTime!
  status: QueueStatus!
  matchedAt: DateTime
  match: Match
}

enum ScrimState {
  PENDING
  POPPED
  IN_PROGRESS
  RATIFYING
  COMPLETE
  LOCKED
  CANCELLED
}

type ScrimTimeout {
  id: String!
  player: Player!
  expiresAt: DateTime!
  reason: String!
}

type SkillGroup {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  name: String!
  code: String!
  game: Game!
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSING
  VALIDATING
  RATIFYING
  RATIFIED
}

type Subscription {
  currentScrim: Scrim
  pendingScrims: Scrim!
  allScrims: Scrim!
}

type Team {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
}

type TeamStat {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  team: Team
  round: Round!
  stats: String!
}

input UpdatePlayerInput {
  playerId: String!
  destinationSkillGroupId: String
  destinationSalary: String
}

type User {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  username: String!
  avatarUrl: String
  allowedActions: [String!]!
  active: Boolean!
  players: [Player!]!
  accounts: [UserAuthAccount!]!
}

type UserAuthAccount {
  platform: AuthPlatform!
  platformId: String!
  platformName: String!
  user: User!
}

type UserNotificationPreference {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime!
  user: User!
  channel: NotificationChannel!
  enabled: Boolean!
  settings: String!
}

type UserRoleAssignment {
  id: ID!
  userId: Int!
  roleId: String!
  role: Role!
  scope: String
  assignedAt: DateTime!
  assignedById: Float
  expiresAt: DateTime
  status: String!
}

